import cv2
import time
import threading
import requests
import numpy as np
from io import BytesIO
from PIL import Image
from bs4 import BeautifulSoup
import random
import subprocess
import socket

# 接続するWi-Fiの設定
SSID = "pepepe-24AES"
CONNECTION_NAME = "pepepe-24AES"  # 通常はSSIDと同じ

def reconnect_wifi():
    print("Wi-Fi再接続中...")
    subprocess.run("nmcli con down '{CONNECTION_NAME}'", shell=True)
    time.sleep(5)
    subprocess.run("nmcli con up '{CONNECTION_NAME}'", shell=True)
    print("再接続完了")

def is_connected():
    gateway_ip = get_default_gateway()
    if not gateway_ip:
        print("⚠ ルーターのIPが見つかりません")
        return False
    print(f"📡 ルーターIP: {gateway_ip}")

    try:
        socket.create_connection((gateway_ip, 80), timeout=3)
        print("✅ 接続成功")
        return True
    except Exception as e:
        print(f"❌ 接続失敗: {e}")
        return False

# グローバル変数を使用して最新の画像とタイムスタンプを管理
latest_image = None
latest_timestamp = None
stop_event = threading.Event()
image_cache = {}

def get_latest_file_url(base_url):
    try:
        response = requests.get(base_url, timeout=5)
        if response.status_code == 200:
            soup = BeautifulSoup(response.text, 'html.parser')
            files = [node.get('href') for node in soup.find_all('a') if node.get('href').endswith('.jpg')]
            
            if files:
                latest_file = files[-1]
                latest_file_url = base_url + latest_file
                return latest_file_url, latest_file
            else:
                print("No image files found on server.", time.strftime('%H:%M:%S'))
                return None, None
        else:
            print(f"Failed to retrieve file list. Status code: {response.status_code}", time.strftime('%H:%M:%S'))
            return None, None
    except Exception as e:
        print(f"Error retrieving file list: {e}", time.strftime('%H:%M:%S'))
        return None, None

def download_image(url):
    retries = 5  # リトライ回数を増やす
    while retries > 0:
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                image = Image.open(BytesIO(response.content))
                return cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)
            else:
                print(f"Failed to download image. Status code: {response.status_code}", time.strftime('%H:%M:%S'))
                retries -= 1
                time.sleep(0.5 + random.uniform(0, 0.5))  # ランダムな待機時間を追加
        except Exception as e:
            print(f"Error downloading image: {e}", time.strftime('%H:%M:%S'))
            retries -= 1
            time.sleep(0.5 + random.uniform(0, 0.5))  # ランダムな待機時間を追加
    return None

def update_image(base_url):
    global latest_image, latest_timestamp, image_cache
    while not stop_event.is_set():
        image_url, latest_file = get_latest_file_url(base_url)
        if image_url:
            if latest_file in image_cache:
                image = image_cache[latest_file]
                print("Using cached image.", time.strftime('%H:%M:%S'))
            else:
                image = download_image(image_url)
                if image is not None:
                    image_cache[latest_file] = image  # キャッシュに保存
                    # キャッシュの制限を設ける（例えば、最新の10枚のみ）
                    if len(image_cache) > 10:
                        oldest_file = list(image_cache.keys())[0]
                        del image_cache[oldest_file]
                    latest_image = image
                    latest_timestamp = time.time()  # 画像が更新された時にタイムスタンプを更新
                    print(f"Image updated at {latest_timestamp}", time.strftime('%H:%M:%S'))
                else:
                    print("Downloaded image is None.", time.strftime('%H:%M:%S'))
        else:
            print("Image URL is None.", time.strftime('%H:%M:%S'))
        time.sleep(1)  # 1秒ごとに更新を試みる

def cv2_putText_2(img, text, org, fontFace, fontScale, color):
    x, y = org
    b, g, r = color
    colorRGB = (r, g, b)
    imgPIL = cv2pil(img)
    draw = ImageDraw.Draw(imgPIL)
    fontPIL = ImageFont.truetype(font = fontFace, size = fontScale)
    w, h = draw.textsize(text, font = fontPIL)
    draw.text(xy = (x,y-h), text = text, fill = colorRGB, font = fontPIL)
    imgCV = pil2cv(imgPIL)
    return imgCV

def draw_overlay(image, timestamp):
    current_time = time.time()
    time_diff = current_time - timestamp
    time_diff_str = f"delay:{time_diff:.1f}sec"  # 0.1秒単位で表示
    timestamp_str = time.strftime('photo:%H:%M:%S', time.localtime(timestamp))
    
    font = cv2.FONT_HERSHEY_SIMPLEX
    font_scale = 2
    color = (255, 255, 255)  # 白色
    thickness = 2
    (w1, h1), _ = cv2.getTextSize(timestamp_str, font, font_scale, thickness)
    (w2, h2), _ = cv2.getTextSize(time_diff_str, font, font_scale, thickness)
    
    # タイムスタンプと時間差を画像にオーバーレイ（右上）
    cv2.putText(image, timestamp_str, (image.shape[1] - w1 - 10, h1 + 10), font, font_scale, (0, 0, 0), thickness * 2, cv2.LINE_AA)
    cv2.putText(image, timestamp_str, (image.shape[1] - w1 - 10, h1 + 10), font, font_scale, color, thickness, cv2.LINE_AA)
    
    cv2.putText(image, time_diff_str, (image.shape[1] - w2 - 10, h1 + h2 + 20), font, font_scale, (0, 0, 0), thickness * 2, cv2.LINE_AA)
    cv2.putText(image, time_diff_str, (image.shape[1] - w2 - 10, h1 + h2 + 20), font, font_scale, color, thickness, cv2.LINE_AA)

base_url = "http://192.168.0.100:8000/"  # サーバーのベースURL

# 画像更新用のスレッドを開始
update_thread = threading.Thread(target=update_image, args=(base_url,), daemon=True)
update_thread.start()

cv2.namedWindow("Image Viewer", cv2.WINDOW_NORMAL)
cv2.setWindowProperty("Image Viewer", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

while True:
	if not is_connected():
        print("ネット未接続。再接続を試みます...")
        reconnect_wifi()

    if latest_image is not None:
        image = latest_image.copy()
        if latest_timestamp is not None:
            draw_overlay(image, latest_timestamp)
        # フルスクリーンで表示されるようにリサイズ
        screen_res = 1920, 1080  # 画面の解像度を指定
        scale_width = screen_res[0] / image.shape[1]
        scale_height = screen_res[1] / image.shape[0]
        scale = min(scale_width, scale_height)
        window_width = int(image.shape[1] * scale)
        window_height = int(image.shape[0] * scale)
        resized_image = cv2.resize(image, (window_width, window_height))
        cv2.imshow("Image Viewer", resized_image)
    
    if cv2.waitKey(500) == 27:  # 0.5秒ごとにチェックし、ESCキーで終了
        stop_event.set()  # スレッド停止フラグを設定
        break

cv2.destroyAllWindows()
update_thread.join()
