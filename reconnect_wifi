import cv2
import time
import threading
import requests
import numpy as np
from io import BytesIO
from PIL import Image, ImageDraw, ImageFont
from bs4 import BeautifulSoup
import random
import subprocess
import socket
import re

# 接続するWi-Fiの設定
SSID = "pepepe-24AES"
CONNECTION_NAME = "pepepe-24AES"  # 通常はSSIDと同じ

def reconnect_wifi():
    print("Wi-Fi再接続中...")
    subprocess.run(f"nmcli con down '{CONNECTION_NAME}'", shell=True)
    time.sleep(5)
    subprocess.run(f"nmcli con up '{CONNECTION_NAME}'", shell=True)
    print("再接続完了")

def get_default_gateway():
    try:
        result = subprocess.run("ip route", shell=True, capture_output=True, text=True)
        match = re.search(r"default via (\S+)", result.stdout)
        if match:
            return match.group(1)
        else:
            return None
    except Exception as e:
        print(f"Error getting gateway IP: {e}")
        return None

def is_connected():
    gateway_ip = get_default_gateway()
    if not gateway_ip:
        print("⚠ ルーターのIPが見つかりません")
        return False
    print(f"📡 ルーターIP: {gateway_ip}")
    try:
        socket.create_connection((gateway_ip, 80), timeout=3)
        print("✅ 接続成功")
        return True
    except Exception as e:
        print(f"❌ 接続失敗: {e}")
        return False

# グローバル変数を使用して最新の画像とタイムスタンプを管理
latest_image = None
latest_timestamp = None
stop_event = threading.Event()
image_cache = {}

def get_latest_file_url(base_url):
    try:
        response = requests.get(base_url, timeout=5)
        if response.status_code == 200:
            soup = BeautifulSoup(response.text, 'html.parser')
            files = [node.get('href') for node in soup.find_all('a') if node.get('href').endswith('.jpg')]
            if files:
                latest_file = files[-1]
                latest_file_url = base_url + latest_file
                return latest_file_url, latest_file
            else:
                print("No image files found on server.", time.strftime('%H:%M:%S'))
                return None, None
        else:
            print(f"Failed to retrieve file list. Status code: {response.status_code}", time.strftime('%H:%M:%S'))
            return None, None
    except Exception as e:
        print(f"Error retrieving file list: {e}", time.strftime('%H:%M:%S'))
        return None, None

def download_image(url):
    retries = 5
    while retries > 0:
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                image = Image.open(BytesIO(response.content))
                return cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)
            else:
                print(f"Failed to download image. Status code: {response.status_code}", time.strftime('%H:%M:%S'))
        except Exception as e:
            print(f"Error downloading image: {e}", time.strftime('%H:%M:%S'))
        retries -= 1
        time.sleep(0.5 + random.uniform(0, 0.5))
    return None

def update_image(base_url):
    global latest_image, latest_timestamp, image_cache
    while not stop_event.is_set():
        image_url, latest_file = get_latest_file_url(base_url)
        if image_url:
            if latest_file in image_cache:
                image = image_cache[latest_file]
                print("Using cached image.", time.strftime('%H:%M:%S'))
            else:
                image = download_image(image_url)
                if image is not None:
                    image_cache[latest_file] = image
                    if len(image_cache) > 10:
                        oldest_file = list(image_cache.keys())[0]
                        del image_cache[oldest_file]
                    latest_image = image
                    latest_timestamp = time.time()
                    print(f"Image updated at {latest_timestamp}", time.strftime('%H:%M:%S'))
                else:
                    print("Downloaded image is None.", time.strftime('%H:%M:%S'))
        else:
            print("Image URL is None.", time.strftime('%H:%M:%S'))
        time.sleep(1)

def draw_overlay(image, timestamp):
    current_time = time.time()
    time_diff = current_time - timestamp
    time_diff_str = f"delay:{time_diff:.1f}sec"
    timestamp_str = time.strftime('photo:%H:%M:%S', time.localtime(timestamp))

    font = cv2.FONT_HERSHEY_SIMPLEX
    font_scale = 2
    color = (255, 255, 255)
    thickness = 2
    (w1, h1), _ = cv2.getTextSize(timestamp_str, font, font_scale, thickness)
    (w2, h2), _ = cv2.getTextSize(time_diff_str, font, font_scale, thickness)

    cv2.putText(image, timestamp_str, (image.shape[1] - w1 - 10, h1 + 10), font, font_scale, (0, 0, 0), thickness * 2, cv2.LINE_AA)
    cv2.putText(image, timestamp_str, (image.shape[1] - w1 - 10, h1 + 10), font, font_scale, color, thickness, cv2.LINE_AA)
    cv2.putText(image, time_diff_str, (image.shape[1] - w2 - 10, h1 + h2 + 20), font, font_scale, (0, 0, 0), thickness * 2, cv2.LINE_AA)
    cv2.putText(image, time_diff_str, (image.shape[1] - w2 - 10, h1 + h2 + 20), font, font_scale, color, thickness, cv2.LINE_AA)

# サーバーURL（必要に応じて変更）
base_url = "http://192.168.0.100:8000/"

# 画像取得用スレッド起動
update_thread = threading.Thread(target=update_image, args=(base_url,), daemon=True)
update_thread.start()

cv2.namedWindow("Image Viewer", cv2.WINDOW_NORMAL)
cv2.setWindowProperty("Image Viewer", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

try:
    while True:
        if not is_connected():
            print("ネット未接続。再接続を試みます...")
            reconnect_wifi()

        if latest_image is not None:
            image = latest_image.copy()
            if latest_timestamp is not None:
                draw_overlay(image, latest_timestamp)

            screen_res = 1920, 1080
            scale_width = screen_res[0] / image.shape[1]
            scale_height = screen_res[1] / image.shape[0]
            scale = min(scale_width, scale_height)
            window_width = int(image.shape[1] * scale)
            window_height = int(image.shape[0] * scale)
            resized_image = cv2.resize(image, (window_width, window_height))
            cv2.imshow("Image Viewer", resized_image)

        if cv2.waitKey(500) == 27:
            stop_event.set()
            break

finally:
    cv2.destroyAllWindows()
    update_thread.join()

